# 计算机操作系统 - 内存管理
<!-- GFM-TOC -->
* [计算机操作系统 - 内存管理](#计算机操作系统---内存管理)
    * [虚拟内存](#虚拟内存)
    * [分页系统地址映射](#分页系统地址映射)
    * [页面置换算法](#页面置换算法)
        * [1. 最佳](#1-最佳)
        * [2. 最近最久未使用](#2-最近最久未使用)
        * [3. 最近未使用](#3-最近未使用)
        * [4. 先进先出](#4-先进先出)
        * [5. 第二次机会算法](#5-第二次机会算法)
        * [6. 时钟](#6-时钟)
    * [分段](#分段)
    * [段页式](#段页式)
    * [分页与分段的比较](#分页与分段的比较)
<!-- GFM-TOC -->


## 虚拟内存

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，发生缺页中断，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0\~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b281b1e-0595-402b-ae35-8c91084c33c1.png"/> </div><br>

## 分页系统地址映射

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量（在该页内的偏移）。

下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。虚拟地址对应的物理地址为 （110 000000000100）。

*原本从虚拟地址到物理地址要通过加偏移量的方式，用分页的方式减少了加法运算*

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"/> </div><center>图从下往上看</center>



## 针对大内存的页表

### 1.多级页表

### 2.倒排页表

对于64位机，地址空间有2^64bytes大（假如一个地址存储1byte），页表的表项将会非常多（2^64/4KB = 2^52），所以用实际内存的页框数目（如1G RAM / 4KB page），一个页框有一个表项



## 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中（页表中记录了该页不在内存），就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

### 1. 最佳

> OPT, Optimal replacement algorithm

所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：

```html
7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
```

开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。

### 2. 最近最久未使用

> LRU, Least Recently Used

虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。

为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

```html
4，7，0，7，1，0，1，2，1，2，6
```

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div><br>
### 3. 最近未使用

> NRU, Not Recently Used

每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时（如时钟中断时）被清零。可以将页面分成以下四类：

- R=0，M=0 没有被访问，没有被修改
- R=0，M=1 没有被访问，已被修改
- R=1，M=0 已被访问，没有被修改
- R=1，M=1 已被访问，已被修改

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

### 4. 先进先出

> FIFO, First In First Out

选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面换出，导致缺页率升高。

### 5. 第二次机会算法

FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：

当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div><br>

### 6. 时钟

> Clock

第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div><br>

## 分段

虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div><br>

分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。

在段式虚拟存储系统中，虚拟地址由段号和段内地址组成，虚拟地址到实存地址的变换通过段表来实现。每个程序设置一个段表，段表的每一个表项对应一个段，每个表项至少包括三个字段：有效位（指明该段是否已经调入主存）、段起址(该段在实存中的首地址)和段长（记录该段的实际长度）。

绝对地址=根据段号找到段表中的起始地址+段内地址 (如果段内地址超过限长则产生“地址越界”程序性中断事件达到存储保护)

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div><br>

## 段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

<img src="https://images.cnblogs.com/cnblogs_com/songsongww/1915225/o_2101120907221610442317(1).png" style="zoom: 67%;"  >



<img src="https://images.cnblogs.com/cnblogs_com/songsongww/1915225/o_2101120913021610442766(1).png" style="zoom:67%;" >



**逻辑地址**----- >段号、段内页号、页内地址

段表寄存器--- >段表始址

段号+段表始址---- >页表始址

页表始址+段内页号----->存储块号

块号+页内地址------>**物理地址**

 <img src="https://img-blog.csdn.net/20131031092005921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"  />

## 分页与分段的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的长度可以动态改变。
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

分段可以给每个进程分配不同的线性地址空间，但是在16MB的地址空间，每个段最长64k，也就是最多可以有256段分配给不同的进程，在有更多进程需要物理内存时，需要把内存中其他的整个进程替换掉。而分页可以用相同的线性地址映射不同的物理地址，如果内存紧张时可以按页替换，理论上对进程的运行数量没有限制，实现了高效的多任务运行。所以在这个时期分段失去了优势。**在Linux内核中，把代码段和数据段的段基址都设置为0，使段偏移地址等于虚拟地址(也就是线性地址)，完全通过分页功能实现多进程运行。**



## 为什么要分段和分页？

首先分页和分段都是为了更好的管理内存，是内存的管理方式。

想象一下，假如没有分段和分页机制的情况是什么样的？ 这种情况下相当于直接操作内存，那么程序员在写代码的时候要自己考虑并写死用哪些物理地址！而且程序的运行一定需要连续的地址来一次装入程序！

上面的情况将引来三个问题：

- 程序之间很容易相互影响，因为是直接操作内存的物理地址，那么程序B可能会出现修改覆盖程序A地址的情况！这种问题可以称为：没有有效隔离进程的地址空间！
- 程序的地址难以把握，因为物理地址是写死的，假如程序写死操作的内存地址范围是0x000000100x00000020，但是装入程序的时候放在了0x000000300x00000040上，那么程序操作的压根不是程序占有的内存地址！
- 换入换出的时候，因为地址必须连续，导致无法利用离散的小内存块！这种问题是内存利用率低！

而<font color="red">分段的引入解决了前两个问题</font>。有了分段机制，会对不同段间实现隔离！跨越段间的访问将会进行权限检查，这实现了隔离保护。并且分段后的地址是虚拟地址，到物理地址的转换是：段基地址+段内偏移地址（未开启分页情况），那么程序员可以不用再费劲的考虑使用那些物理地址，地址都可以从0开始.

而分页的引入解决了第三个问题。分页机制和分段机制是非常类似的，他们都实现了隔离保护，分页是不同进程使用不同的页映射关系（页表），因此不同进程间互不影响。而且分页也不需要考虑如何操作物理地址了，分页后的地址称为线性地址，其关系是通过页表实现虚拟地址到物理地址的一一对应，这个对应是由MMU硬件实现的，不用程序员操心！而且分页和分段对于虚拟地址的映射方式基本一致，**分段是通过段表GDT，LDT中的段描述符来确定段的属性和物理地址范围; 而分页是通过页表项（页表描述符）来记录页框的属性和物理地址位置！**